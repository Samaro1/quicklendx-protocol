#![cfg(test)]
extern crate alloc;

use crate::invoice::InvoiceCategory;
use crate::verification::BusinessVerificationStatus;
use crate::QuickLendXContract;
use soroban_sdk::{
    testutils::{Address as _, Ledger},
    Address, Env, String, Vec,
};

// The client is auto-generated by the Soroban SDK
type QuickLendXContractClient<'a> = crate::QuickLendXContractClient<'a>;

/// Setup function for tests
fn setup() -> (Env, QuickLendXContractClient<'static>, Address) {
    let env = Env::default();
    env.mock_all_auths();
    let contract_id = env.register(QuickLendXContract, ());
    let client = QuickLendXContractClient::new(&env, &contract_id);

    // Set up admin
    let admin = Address::generate(&env);
    client.set_admin(&admin);

    (env, client, admin)
}

/// Helper function to create test KYC data
fn create_test_kyc_data(env: &Env, business_name: &str) -> String {
    let kyc_json = alloc::format!(
        "{{\"business_name\":\"{}\",\"tax_id\":\"123456789\",\"registration_number\":\"REG123\",\"address\":\"123 Business St\",\"phone\":\"+1234567890\",\"email\":\"{}@example.com\"}}",
        business_name,
        business_name.to_lowercase()
    );
    String::from_str(env, &kyc_json)
}

// ============================================================================
// Business KYC Submission Tests
// ============================================================================

#[test]
fn test_business_can_submit_own_kyc() {
    let (env, client, _admin) = setup();
    let business = Address::generate(&env);
    let kyc_data = create_test_kyc_data(&env, "TestBusiness");

    // Advance ledger time to ensure timestamp is not 0
    env.ledger().with_mut(|li| li.timestamp = 1000);

    // Business should be able to submit their own KYC
    client.submit_kyc_application(&business, &kyc_data);

    // Verify KYC was submitted correctly
    let verification = client.get_business_verification_status(&business);

    assert!(verification.is_some());

    let verification = verification.unwrap();
    assert_eq!(verification.business, business);
    assert_eq!(verification.kyc_data, kyc_data);
    assert!(matches!(
        verification.status,
        BusinessVerificationStatus::Pending
    ));
    assert!(verification.verified_at.is_none());
    assert!(verification.verified_by.is_none());
    assert!(verification.rejection_reason.is_none());
    assert!(verification.submitted_at > 0);
}

#[test]
fn test_business_cannot_submit_kyc_for_another_business() {
    let (env, client, _admin) = setup();
    let business_a = Address::generate(&env);
    let business_b = Address::generate(&env);
    let kyc_data = create_test_kyc_data(&env, "TestBusiness");

    // Business A submits their own KYC (should work)
    client.submit_kyc_application(&business_a, &kyc_data);

    // Verify only business A has KYC submitted
    let verification_a = client.get_business_verification_status(&business_a);
    let verification_b = client.get_business_verification_status(&business_b);

    assert!(verification_a.is_some());
    assert!(verification_b.is_none());
}

#[test]
fn test_kyc_submission_with_empty_data() {
    let (env, client, _admin) = setup();
    let business = Address::generate(&env);
    let empty_kyc_data = String::from_str(&env, "");

    // Submit KYC with empty data - should succeed at contract level
    client.submit_kyc_application(&business, &empty_kyc_data);

    let verification = client.get_business_verification_status(&business);
    assert!(verification.is_some());
    assert_eq!(verification.unwrap().kyc_data, empty_kyc_data);
}

#[test]
fn test_kyc_already_pending_error() {
    let (env, client, _admin) = setup();
    let business = Address::generate(&env);
    let kyc_data = create_test_kyc_data(&env, "TestBusiness");

    // Submit KYC application
    client.submit_kyc_application(&business, &kyc_data);

    // Try to submit again - should fail with KYCAlreadyPending error
    let result = client.try_submit_kyc_application(&business, &kyc_data);
    assert!(result.is_err());
}

#[test]
fn test_kyc_already_verified_error() {
    let (env, client, admin) = setup();
    let business = Address::generate(&env);
    let kyc_data = create_test_kyc_data(&env, "TestBusiness");

    // Submit and verify KYC
    client.submit_kyc_application(&business, &kyc_data);
    client.verify_business(&admin, &business);

    // Try to submit KYC again - should fail with KYCAlreadyVerified error
    let result = client.try_submit_kyc_application(&business, &kyc_data);
    assert!(result.is_err());
}

#[test]
fn test_kyc_resubmission_after_rejection() {
    let (env, client, admin) = setup();
    let business = Address::generate(&env);
    let kyc_data = create_test_kyc_data(&env, "TestBusiness");
    let rejection_reason = String::from_str(&env, "Incomplete documentation");

    // Submit KYC application
    client.submit_kyc_application(&business, &kyc_data);

    // Reject the application
    client.reject_business(&admin, &business, &rejection_reason);

    // Verify rejection
    let verification = client.get_business_verification_status(&business);
    assert!(verification.is_some());
    let verification = verification.unwrap();
    assert!(matches!(
        verification.status,
        BusinessVerificationStatus::Rejected
    ));
    assert_eq!(verification.rejection_reason, Some(rejection_reason));

    // Business should be able to resubmit after rejection
    let new_kyc_data = create_test_kyc_data(&env, "TestBusinessUpdated");
    client.submit_kyc_application(&business, &new_kyc_data);

    // Verify resubmission was successful
    let verification = client.get_business_verification_status(&business);
    assert!(verification.is_some());
    let verification = verification.unwrap();
    assert!(matches!(
        verification.status,
        BusinessVerificationStatus::Pending
    ));
    assert_eq!(verification.kyc_data, new_kyc_data);
    assert!(verification.rejection_reason.is_none()); // Should be cleared on resubmission
}

// ============================================================================
// Admin Verification Tests
// ============================================================================

#[test]
fn test_only_admin_can_verify_business() {
    let (env, client, admin) = setup();
    let business = Address::generate(&env);
    let non_admin = Address::generate(&env);
    let kyc_data = create_test_kyc_data(&env, "TestBusiness");

    // Submit KYC application
    client.submit_kyc_application(&business, &kyc_data);

    // Non-admin tries to verify - should fail
    let result = client.try_verify_business(&non_admin, &business);
    assert!(result.is_err());

    // Admin verifies - should succeed
    client.verify_business(&admin, &business);

    // Verify the business is now verified
    let verification = client.get_business_verification_status(&business);
    assert!(verification.is_some());
    let verification = verification.unwrap();
    assert!(matches!(
        verification.status,
        BusinessVerificationStatus::Verified
    ));
    assert!(verification.verified_at.is_some());
    assert_eq!(verification.verified_by, Some(admin));
}

#[test]
fn test_only_admin_can_reject_business() {
    let (env, client, admin) = setup();
    let business = Address::generate(&env);
    let non_admin = Address::generate(&env);
    let kyc_data = create_test_kyc_data(&env, "TestBusiness");
    let rejection_reason = String::from_str(&env, "Insufficient documentation");

    // Submit KYC application
    client.submit_kyc_application(&business, &kyc_data);

    // Non-admin tries to reject - should fail
    let result = client.try_reject_business(&non_admin, &business, &rejection_reason);
    assert!(result.is_err());

    // Admin rejects - should succeed
    client.reject_business(&admin, &business, &rejection_reason);

    // Verify the business is now rejected
    let verification = client.get_business_verification_status(&business);
    assert!(verification.is_some());
    let verification = verification.unwrap();
    assert!(matches!(
        verification.status,
        BusinessVerificationStatus::Rejected
    ));
    assert_eq!(verification.rejection_reason, Some(rejection_reason));
}

// ============================================================================
// Business Authorization Tests
// ============================================================================

#[test]
fn test_unverified_business_cannot_upload_invoice() {
    let (env, client, _admin) = setup();
    let business = Address::generate(&env);
    let currency = Address::generate(&env);
    let amount = 1000i128;
    let due_date = env.ledger().timestamp() + 86400; // 1 day from now
    let description = String::from_str(&env, "Test invoice");
    let category = InvoiceCategory::Services;
    let tags = Vec::new(&env);

    // Try to upload invoice without verification - should fail
    let result = client.try_upload_invoice(
        &business,
        &amount,
        &currency,
        &due_date,
        &description,
        &category,
        &tags,
    );
    assert!(result.is_err());
}

#[test]
fn test_verified_business_can_upload_invoice() {
    let (env, client, admin) = setup();
    let business = Address::generate(&env);
    let currency = Address::generate(&env);
    let amount = 1000i128;
    let due_date = env.ledger().timestamp() + 86400;
    let description = String::from_str(&env, "Test invoice");
    let category = InvoiceCategory::Services;
    let tags = Vec::new(&env);
    let kyc_data = create_test_kyc_data(&env, "TestBusiness");

    // Submit and verify KYC
    client.submit_kyc_application(&business, &kyc_data);
    client.verify_business(&admin, &business);

    // Upload invoice - should succeed
    let invoice_id = client.upload_invoice(
        &business,
        &amount,
        &currency,
        &due_date,
        &description,
        &category,
        &tags,
    );

    // Verify invoice was created
    let invoice = client.get_invoice(&invoice_id);
    assert_eq!(invoice.business, business);
    assert_eq!(invoice.amount, amount);
    assert_eq!(invoice.description, description);
}

// ============================================================================
// KYC Status Query Tests
// ============================================================================

#[test]
fn test_get_business_verification_status_returns_none_for_unsubmitted() {
    let (env, client, _admin) = setup();
    let business = Address::generate(&env);

    // Business that hasn't submitted KYC should return None
    let verification = client.get_business_verification_status(&business);
    assert!(verification.is_none());
}

#[test]
fn test_get_verification_lists() {
    let (env, client, admin) = setup();
    let business1 = Address::generate(&env);
    let business2 = Address::generate(&env);
    let business3 = Address::generate(&env);
    let kyc_data = create_test_kyc_data(&env, "TestBusiness");
    let rejection_reason = String::from_str(&env, "Test rejection");

    // Submit KYC for all businesses
    client.submit_kyc_application(&business1, &kyc_data);
    client.submit_kyc_application(&business2, &kyc_data);
    client.submit_kyc_application(&business3, &kyc_data);

    // Verify business1, reject business2, leave business3 pending
    client.verify_business(&admin, &business1);
    client.reject_business(&admin, &business2, &rejection_reason);

    // Check lists
    let verified = client.get_verified_businesses();
    let pending = client.get_pending_businesses();
    let rejected = client.get_rejected_businesses();

    assert_eq!(verified.len(), 1);
    assert!(verified.contains(&business1));

    assert_eq!(pending.len(), 1);
    assert!(pending.contains(&business3));

    assert_eq!(rejected.len(), 1);
    assert!(rejected.contains(&business2));
}

// ============================================================================
// Integration Tests
// ============================================================================

#[test]
fn test_complete_business_kyc_to_invoice_flow() {
    let (env, client, admin) = setup();
    let business = Address::generate(&env);
    let currency = Address::generate(&env);
    let kyc_data = create_test_kyc_data(&env, "TestBusiness");

    // Step 1: Business submits KYC
    client.submit_kyc_application(&business, &kyc_data);

    let verification = client.get_business_verification_status(&business);
    assert!(verification.is_some());
    assert!(matches!(
        verification.unwrap().status,
        BusinessVerificationStatus::Pending
    ));

    // Step 2: Admin verifies business
    client.verify_business(&admin, &business);

    let verification = client.get_business_verification_status(&business);
    assert!(verification.is_some());
    assert!(matches!(
        verification.unwrap().status,
        BusinessVerificationStatus::Verified
    ));

    // Step 3: Business uploads invoice
    let amount = 1000i128;
    let due_date = env.ledger().timestamp() + 86400;
    let description = String::from_str(&env, "Test invoice for verified business");
    let category = InvoiceCategory::Services;
    let tags = Vec::new(&env);

    let invoice_id = client.upload_invoice(
        &business,
        &amount,
        &currency,
        &due_date,
        &description,
        &category,
        &tags,
    );

    // Step 4: Verify invoice was created correctly
    let invoice = client.get_invoice(&invoice_id);
    assert_eq!(invoice.business, business);
    assert_eq!(invoice.amount, amount);
    assert_eq!(invoice.description, description);

    // Step 5: Admin verifies invoice
    client.verify_invoice(&invoice_id);

    let invoice = client.get_invoice(&invoice_id);
    assert!(matches!(
        invoice.status,
        crate::invoice::InvoiceStatus::Verified
    ));
}

#[test]
fn test_rejected_business_resubmission_flow() {
    let (env, client, admin) = setup();
    let business = Address::generate(&env);
    let currency = Address::generate(&env);
    let kyc_data = create_test_kyc_data(&env, "TestBusiness");
    let rejection_reason = String::from_str(&env, "Incomplete tax documentation");

    // Step 1: Submit initial KYC
    client.submit_kyc_application(&business, &kyc_data);

    // Step 2: Admin rejects
    client.reject_business(&admin, &business, &rejection_reason);

    let verification = client.get_business_verification_status(&business);
    assert!(verification.is_some());
    assert!(matches!(
        verification.unwrap().status,
        BusinessVerificationStatus::Rejected
    ));

    // Step 3: Business cannot upload invoice while rejected
    let amount = 1000i128;
    let due_date = env.ledger().timestamp() + 86400;
    let description = String::from_str(&env, "Test invoice");
    let category = InvoiceCategory::Services;
    let tags = Vec::new(&env);

    let result = client.try_upload_invoice(
        &business,
        &amount,
        &currency,
        &due_date,
        &description,
        &category,
        &tags,
    );
    assert!(result.is_err());

    // Step 4: Business resubmits with updated KYC
    let updated_kyc_data = create_test_kyc_data(&env, "TestBusinessUpdated");
    client.submit_kyc_application(&business, &updated_kyc_data);

    let verification = client.get_business_verification_status(&business);
    assert!(verification.is_some());
    let verification = verification.unwrap();
    assert!(matches!(
        verification.status,
        BusinessVerificationStatus::Pending
    ));
    assert_eq!(verification.kyc_data, updated_kyc_data);

    // Step 5: Admin verifies updated KYC
    client.verify_business(&admin, &business);

    // Step 6: Business can now upload invoice
    let invoice_id = client.upload_invoice(
        &business,
        &amount,
        &currency,
        &due_date,
        &description,
        &category,
        &tags,
    );

    let invoice = client.get_invoice(&invoice_id);
    assert_eq!(invoice.business, business);
}

// ============================================================================
// Edge Cases and Security Tests
// ============================================================================

#[test]
fn test_multiple_businesses_independent_kyc_processes() {
    let (env, client, admin) = setup();
    let business1 = Address::generate(&env);
    let business2 = Address::generate(&env);
    let kyc_data1 = create_test_kyc_data(&env, "Business1");
    let kyc_data2 = create_test_kyc_data(&env, "Business2");

    // Both businesses submit KYC independently
    client.submit_kyc_application(&business1, &kyc_data1);
    client.submit_kyc_application(&business2, &kyc_data2);

    // Verify only business1
    client.verify_business(&admin, &business1);

    // Check that business1 is verified and business2 is still pending
    let verification1 = client.get_business_verification_status(&business1);
    let verification2 = client.get_business_verification_status(&business2);

    assert!(verification1.is_some());
    assert!(matches!(
        verification1.unwrap().status,
        BusinessVerificationStatus::Verified
    ));

    assert!(verification2.is_some());
    assert!(matches!(
        verification2.unwrap().status,
        BusinessVerificationStatus::Pending
    ));
}

#[test]
fn test_kyc_data_integrity() {
    let (env, client, admin) = setup();
    let business = Address::generate(&env);
    let original_kyc_data = create_test_kyc_data(&env, "OriginalBusiness");

    // Submit KYC
    client.submit_kyc_application(&business, &original_kyc_data);

    // Verify the data is stored correctly
    let verification = client.get_business_verification_status(&business);
    assert!(verification.is_some());
    assert_eq!(verification.unwrap().kyc_data, original_kyc_data);

    // Verify business
    client.verify_business(&admin, &business);

    // Ensure data is still intact after verification
    let verification = client.get_business_verification_status(&business);
    assert!(verification.is_some());
    assert_eq!(verification.unwrap().kyc_data, original_kyc_data);
}

#[test]
fn test_timestamp_accuracy() {
    let (env, client, admin) = setup();
    let business = Address::generate(&env);
    let kyc_data = create_test_kyc_data(&env, "TestBusiness");

    let submission_time = env.ledger().timestamp();

    // Submit KYC
    client.submit_kyc_application(&business, &kyc_data);

    let verification = client.get_business_verification_status(&business);
    assert!(verification.is_some());
    let verification = verification.unwrap();

    // Submitted timestamp should be at or after submission time
    assert!(verification.submitted_at >= submission_time);

    let verification_time = env.ledger().timestamp();

    // Verify business
    client.verify_business(&admin, &business);

    let verification = client.get_business_verification_status(&business);
    assert!(verification.is_some());
    let verification = verification.unwrap();

    // Verified timestamp should be at or after verification time
    assert!(verification.verified_at.is_some());
    assert!(verification.verified_at.unwrap() >= verification_time);
}
